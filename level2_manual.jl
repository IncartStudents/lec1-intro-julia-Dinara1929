# Выболнить большую часть заданий ниже - привести примеры кода под каждым комментарием


#===========================================================================================
1. Переменные и константы, области видимости, cистема типов:
приведение к типам,
конкретные и абстрактные типы,
множественная диспетчеризация,
=#

# Что происходит с глобальной константой PI, о чем предупреждает интерпретатор?
const PI = 3.14159
PI = 3.14
#WARNING: redefinition of constant Main.PI. This may fail, cause incorrect answers, or produce other errors.    


# Что происходит с типами глобальных переменных ниже, какого типа `c` и почему?
a = 1
b = 2.0
c = a + b
#переменным присвоенны типы данных и значения

# Что теперь произошло с переменной а? Как происходит биндинг имен в Julia?
a = "foo"
#тип и значение а изменли

# Что происходит с глобальной переменной g и почему? Чем ограничен биндинг имен в Julia?
g::Int = 1
g = "hi"
#MethodError: Cannot `convert` an object of type String to an object of type Int64

function greet()
    g = "hello"
    println(g)
end
greet()
#hello

# Чем отличаются присвоение значений новому имени - и мутация значений?
v = [1,2,3]
z = v
v[1] = 3 #тип данных не изменен
v = "hello" #изменился тип и значения
z #вывел последнюю версию v перед изменением данных

# Написать тип, параметризованный другим типом
struct NN
    bar
    Name::String
    Number::Int
end
typeof(NN)#typeof(one) = Vector{Any}
#=
Написать функцию для двух аругментов, не указывая их тип,
и вторую функцию от двух аргментов с конкретными типами,
дать пример запуска
=#
function f(x, y)
    x + y
end
function ff(x::Int, y::Int)
    x + y
end
#=
julia> @show f(3,3)
f(3, 3) = 6
6

julia> typeof(f(3,3))
Int64

julia> @show ff(3,3)
ff(3, 3) = 6
6

julia> typeof(ff(3,3))
Int64
=#
#=
Абстрактный тип - ключевое слово? abstract type «name» end
Примитивный тип - ключевое слово? primitive type
Композитный тип - ключевое слово? struct
=#

#=
Написать один абстрактный тип и два его подтипа (1 и 2)
Написать функцию над абстрактным типом, и функцию над её подтипом-1
Выполнить функции над объектами подтипов 1 и 2 и объяснить результат
(функция выводит произвольный текст в консоль)
=#
abstract type Pet end
struct Dog <: Pet; name::String end
struct Cat <: Pet; name::String end

function encounter(a::Pet, b::Pet)
    verb = meets(a, b)
    println("$(a.name) встречает $(b.name) и $verb.")
end

meets(a::Dog, b::Dog) = "нюхает"
meets(a::Dog, b::Cat) = "гонится"
meets(a::Cat, b::Dog) = "шипит"
meets(a::Cat, b::Cat) = "мурлычит"

fido = Dog("Рекс")
rex = Dog("Мухтар")
whiskers = Cat("Матроскин")
spots = Cat("Бегемот")

encounter(fido, rex)       
encounter(fido, whiskers)  
encounter(whiskers, rex)   
encounter(whiskers, spots) 
#===========================================================================================
2. Функции:
лямбды и обычные функции,
переменное количество аргументов,
именованные аргументы со значениями по умолчанию,
кортежи
=#

# Пример обычной функции
function f(x, y)
    x + y
end
f(3,2)
# Пример лямбда-функции (аннонимной функции)
(x->x^2)(2)
# Пример функции с переменным количеством аргументов
function f(x)
    2*x
end
function f(x, y)
    x^2 + y
end
function f(x, y, z)
    x^2 + 2*y + z
end
f(2)
f(1, 3)
f(2, 1, 4)
function ff(x, y=5)
    x*5+y
end
ff(2)
ff(2, 1)
# Пример функции с именованными аргументами
function hi(name; word = "Hello")
    println(word, ", ", name)
end
hi("Terra")
# Функции с переменным кол-вом именованных аргументов
bar(a,b;x=2,y=3) = (a,b,x*y,y)
bar(1,2)
bar(1,1,x=1)
bar(1,2,x=3,y=4)
#=
Передать кортеж в функцию, которая принимает на вход несколько аргументов.
Присвоить кортеж результату функции, которая возвращает несколько аргументов.
Использовать splatting - деструктуризацию кортежа в набор аргументов.
=#
function fff(x, y, z)
    x^2 + 2*y + z
end
a=(2, 5, 4)
fff(a...)#Использовать splatting - деструктуризацию кортежа в набор аргументов.
#Передать кортеж в функцию, которая принимает на вход несколько аргументов.
function q(x)
    x*2,
    x^2
end
q(3)
#Присвоить кортеж результату функции, которая возвращает несколько аргументов.
#===========================================================================================
3. loop fusion, broadcast, filter, map, reduce, list comprehension
=#

#=
Перемножить все элементы массива
- через loop fusion и
- с помощью reduce
=#
x=[1,2,3,4]
@show x.*2
#loop fusion
reduce(*, x) #reduce
#=
Написать функцию от одного аргумента и запустить ее по всем элементам массива
с помощью точки (broadcast)
c помощью map
c помощью list comprehension
указать, чем это лучше явного цикла?
=#
function p(x)
    x*2
end
a=[0,1,2,3,4,5]

p.(a)
map(x -> x * 2, a)
[f(x) for x in a]
# Перемножить вектор-строку [1 2 3] на вектор-столбец [10,20,30] и объяснить результат


# В одну строку выбрать из массива [1, -2, 2, 3, 4, -5, 0] только четные и положительные числа


# Объяснить следующий код обработки массива names - что за number мы в итоге определили?
using Random
Random.seed!(123)
names = [rand('A':'Z') * '_' * rand('0':'9') * rand([".csv", ".bin"]) for _ in 1:100]
# ---
same_names = unique(map(y -> split(y, ".")[1], filter(x -> startswith(x, "A"), names)))
numbers = parse.(Int, map(x -> split(x, "_")[end], same_names))
numbers_sorted = sort(numbers)
number = findfirst(n -> !(n in numbers_sorted), 0:9)

# Упростить этот код обработки:


#===========================================================================================
4. Свой тип данных на общих интерфейсах
=#

#=
написать свой тип ленивого массива, каждый элемент которого
вычисляется при взятии индекса (getindex) по формуле (index - 1)^2
=#

#=
Написать два типа объектов команд, унаследованных от AbstractCommand,
которые применяются к массиву:
`SortCmd()` - сортирует исходный массив
`ChangeAtCmd(i, val)` - меняет элемент на позиции i на значение val
Каждая команда имеет конструктор и реализацию метода apply!
=#
abstract type AbstractCommand end
apply!(cmd::AbstractCommand, target::Vector) = error("Not implemented for type $(typeof(cmd))")


# Аналогичные команды, но без наследования и в виде замыканий (лямбда-функций)


#===========================================================================================
5. Тесты: как проверять функции?
=#

# Написать тест для функции


#===========================================================================================
6. Дебаг: как отладить функцию по шагам?
=#

#=
Отладить функцию по шагам с помощью макроса @enter и точек останова
=#


#===========================================================================================
7. Профилировщик: как оценить производительность функции?
=#

#=
Оценить производительность функции с помощью макроса @profview,
и добавить в этот репозиторий файл со скриншотом flamechart'а
=#
function generate_data(len)
    vec1 = Any[]
    for k = 1:len
        r = randn(1,1)
        append!(vec1, r)
    end
    vec2 = sort(vec1)
    vec3 = vec2 .^ 3 .- (sum(vec2) / len)
    return vec3
end

@time generate_data(1_000_000);


# Переписать функцию выше так, чтобы она выполнялась быстрее:


#===========================================================================================
8. Отличия от матлаба: приращение массива и предварительная аллокация?
=#

#=
Написать функцию определения первой разности, которая принимает и возвращает массив
и для каждой точки входного (x) и выходного (y) выходного массива вычисляет:
y[i] = x[i] - x[i-1]
=#

#=
Аналогичная функция, которая отличается тем, что внутри себя не аллоцирует новый массив y,
а принимает его первым аргументом, сам массив аллоцируется до вызова функции
=#

#=
Написать код, который добавляет элементы в конец массива, в начало массива,
в середину массива
=#


#===========================================================================================
9. Модули и функции: как оборачивать функции внутрь модуля, как их экспортировать
и пользоваться вне модуля?
=#


#=
Написать модуль с двумя функциями,
экспортировать одну из них,
воспользоваться обеими функциями вне модуля
=#
module Foo
    #export ?
end
# using .Foo ?
# import .Foo ?


#===========================================================================================
10. Зависимости, окружение и пакеты
=#

# Что такое environment, как задать его, как его поменять во время работы?

# Что такое пакет (package), как добавить новый пакет?

# Как начать разрабатывать чужой пакет?

#=
Как создать свой пакет?
(необязательно, эксперименты с PkgTemplates проводим вне этого репозитория)
=#


#===========================================================================================
11. Сохранение переменных в файл и чтение из файла.
Подключить пакеты JLD2, CSV.
=#

# Сохранить и загрузить произвольные обхекты в JLD2, сравнить их

# Сохранить и загрузить табличные объекты (массивы) в CSV, сравнить их


#===========================================================================================
12. Аргументы запуска Julia
=#

#=
Как задать окружение при запуске?
=#

#=
Как задать скрипт, который будет выполняться при запуске:
а) из файла .jl
б) из текста команды? (см. флаг -e)
=#

#=
После выполнения задания Boids запустить julia из командной строки,
передав в виде аргумента имя gif-файла для сохранения анимации
=#
